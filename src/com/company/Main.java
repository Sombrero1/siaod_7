package com.company;

public class Main {


    //Вариант 2
    public static void main(String[] args) {
	// write your code here
        int[] test = { 5,10,3,12,5,50,6};
        System.out.println("answer: "+matrix(test));
    }

    //в решение используется идея динамического программирования (разделяй и властвуй + хранение промежуточных значений)
    //задача делится на подзадачи путём перебора всех возможных вариантов скобок вплоть когда у нас 1 элемент (тогда 0 вариантов). При каждом варианте у нас
    //есть "вес" данного выбора скобок, что эквивалентно количеству перемножений
    public static int matrix(int [] p){
        int [][]m=new int[p.length-1][p.length-1];//двумерный массив для промежуточных результатов (дин. прогр.)
        int n=p.length-1; //кол-во матриц


        //O(n^2) памяти
        for (int i = 0; i < n; i++) {
            m[i][i]=0;
        }

        //O(n^3)
        for (int l = 1; l < n; l++) {//смещение на один элемент вправо
            for (int i = 0; i < n-l; i++) {
                int j=i+l; //вторая координата для ориентации в массиве (т.к. по главной диагонали нуль)
                m[i][j]=Integer.MAX_VALUE;//задаём изначальное значение, оно 100% заменится при первом шаге ниже
                for (int k = i; k < j; k++) {
                    m[i][j]=Math.min(m[i][j], //хранение значений происходит здесь, когда мы ищем минимум не считая повторно предыдущее
                    m[i][k]+m[k+1][j]+
                            p[i]*p[k+1]*p[j+1]//отличается от мат. формулы из-за счёта i с нуля (иначе пришлось бы излишне расширять двумерный массив на столбец)
                    );
                    if(i==n-l-1 && l==n-1)//что то же самое что i==0 && l==n-1 т.к. последний m[i][j]
                    System.out.println( m[i][k]+m[k+1][j]+ //вывод всех вариантов расстановок скобок
                            p[i]*p[k+1]*p[j+1]);
                }
                
            }
            
        }


        return m[0][n-1];//самая верхняя правая ячейка ответ. Вообще мы пробегаемся по массиву грубо говоря, вправо вверх, считая формулу и находя минимумы, по итоге последний минимум,
        //один из  вариантов (выводя m[i][k] на последнем l и i в консоль выводятся альтернативное количество (что позволяет оценить практический смысл)))
    }


}
